{
    "project": {
        "title": "FOG - File Ontology for Geometry formats",
        "creator": "Mathias Bonduel, Anna Wagner & Pieter Pauwels"
    },
    "tabs": [
		{
		  "title": "0: FOG L2 - intro",
		  "query": "PREFIX beo: <http://pi.pauwel.be/voc/buildingelement#>\nPREFIX bot: <https://w3id.org/bot#>\nPREFIX inst: <http://example.org/columns#>\nPREFIX geom: <http://rdf.bg/geometry.ttl#>\nPREFIX omg: <https://w3id.org/omg#>\nPREFIX owl: <http://www.w3.org/2002/07/owl#>\nPREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nPREFIX xsd: <http://www.w3.org/2001/XMLSchema#>\nPREFIX fog: <https://w3id.org/fog#>\n\nCONSTRUCT { ?s ?p ?o }\nWHERE { \n  ?s ?p ?o .\n  FILTER (?o != owl:Thing)\n  FILTER (?o != owl:NamedIndividual)\n}",
		  "triples": "@prefix beo: <http://pi.pauwel.be/voc/buildingelement#> .\n@prefix bot: <https://w3id.org/bot#> .\n@prefix inst: <https://example.org/data#> .\n@prefix geometry: <http://rdf.bg/geometry.ttl#> .\n@prefix omg: <https://w3id.org/omg#> .\n@prefix owl: <http://www.w3.org/2002/07/owl#> .\n@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .\n@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .\n@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .\n@prefix fog: <https://w3id.org/fog#> .\n\n### column 1\ninst:column1 a bot:Element , beo:Column-COLUMN ;\n\tbot:hasSubElement inst:column1-capital , inst:column1-shaft , inst:column1-base ;\n\tomg:hasGeometry inst:geometry4 .\ninst:geometry4 a omg:Geometry ;\n\tfog:asStep_ap214 \"a .step AP 214 literal\"^^xsd:string .\n\ninst:column1-capital a bot:Element ;\n\tomg:hasGeometry inst:geometry1 .\ninst:geometry1 a omg:Geometry ;\n\tfog:asObj_v3.0-obj \"a .obj literal\"^^xsd:string ;\n\tfog:hasReferencedContent inst:refContent1 .\ninst:refContent1 a fog:ReferencedContent ;\n\tfog:asObj_v3.0-mtl \"a referenced .mtl literal\"^^xsd:string ;\n\trdfs:label \"fileName.mtl\" .\n\ninst:column1-shaft a bot:Element ;\n\tomg:hasGeometry inst:geometry2 .\ninst:geometry2 a omg:Geometry ;\n\tfog:asPly_v1.0-ascii \"an ascii .ply literal\"^^xsd:anyURI .\n\ninst:column1-base a bot:Element ;\n\tomg:hasGeometry inst:geometry3 .\ninst:geometry3 a omg:Geometry ;\n\tfog:asGltf_v2.0-gltf \"a .gltf literal (embedded geometry)\"^^xsd:string .\n\n### column 2\ninst:column2 a bot:Element , beo:Column-COLUMN ;\n\tbot:hasSubElement inst:column2-capital , inst:column2-shaft , inst:column2-base ;\n\tomg:hasGeometry inst:geometry8 .\ninst:geometry8 a omg:Geometry ;\n\tfog:asE57_v1.0 \"a E57 literal\"^^xsd:anyURI .\n\ninst:column2-capital a bot:Element ;\n\tomg:hasGeometry inst:geometry5a , inst:geometry5b .\ninst:geometry5a a omg:Geometry ;\n\tfog:asGeomOntology inst:box3 .\ninst:box3 a geometry:Box . #more geometry nodes are connected to this top geometry node\ninst:geometry5b a omg:Geometry ;\n\tfog:asCollada_v1.4.1 \"a .dae COLLADA literal\"^^xsd:anyURI .\n\ninst:column2-shaft a bot:Element ;\n\tomg:hasGeometry inst:geometry6 .\ninst:geometry6 a omg:Geometry ;\n\tfog:asPly_v1.0-binaryLE \"a binary LE .ply literal\"^^xsd:base64Binary .\n\ninst:column2-base a bot:Element ;\n\tomg:hasGeometry inst:geometry7 .\ninst:geometry7 a omg:Geometry ;\n\tfog:asGltf_v2.0-glb \"a .glb literal\"^^xsd:hexBinary .",
		  "description": "This introduction tab contains the sample triples used in the other five tabs. In the sample data, we have two column elements (`ex:column1` and `ex:column2`) that both consist of three subparts (base - shaft - capital). Both the column and its subparts nodes have geometry connected using a combination of FOG and OMG relations (Level 2 geometry). Both \"simple\" (geometry stored in RDF literals) and \"complex\" (RDF-based) geometry descriptions are used in the graph for demonstration purposes.\n\nThe graph visualisation shows all the sample triples. If you connect the sparql-visualizer with a Stardog RDF triplestore, you can load the FOG ontology and turn on reasoning for the query. It will then also visualise the superproperties of the asserted FOG property that relates to the used geometry format.\n\n**NOTE!** Don't forget to load the sample triples in your local Stardog, if you plan to go through the following tabs. Click on \"Load dataset\" (main graph) after having setup the correct endpoint, database name, username and password of your Stardog instance.\n\n** NOTE!** Some of these tabs (incl. this one) demand the use of reasoning. Add the [FOG ontology](https://raw.githubusercontent.com/mathib/fog-ontology/master/fogOnto.ttl) to a named graph `http://ontologies.org/fog/` in your [running Stardog database](localhost:5820) and do not forget to turn reasoning on in the query component of the SPARQL-visualizer (lower right hand corner). If the query returns no results, press the \"Reset\" button in the query component and reactivate \"Reasoning\".\n"
		},
        {
            "title": "1a: SELECT specific geometry of any element (without reasoning)",
            "query": "PREFIX omg: <https://w3id.org/omg#>\nPREFIX owl: <http://www.w3.org/2002/07/owl#>\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nPREFIX fog: <https://w3id.org/fog#>\n\nSELECT ?value ?property ?datatype WHERE {\n    ?geometry ?property ?value ;\n    \ta omg:Geometry .\n    BIND(DATATYPE(?value) AS ?datatype)\n    # only return asserted properties\n    GRAPH <http://ontologies.org/fog/>{\n    \t?property rdfs:subPropertyOf* omg:hasSimpleGeometryDescription .\n    }\n   \tFILTER (?property IN (fog:asGltf_v2.0-glb , fog:asPly_v1.0-ascii))\n}",
            "triples": "",
            "description": "This first query SELECTS **specific geometry**  (in this example: `fog:asGltf_v2.0-glb` and `fog:asPly_v1.0-ascii`) it can find in the graph connected to any building element and returns the asserted geometry format (the FOG relation), the datatype for the encoding OR external referenced file (`xsd:string` / `xsd:base64Binary`/ `xsd:hexBinary` OR `xsd:anyURI`) and the actual geometry description (a unicode string in the case of a RDF literal (\"simple\") or the first node of a RDF-based (\"complex\") geometry).\n\nThe returned variables are:\n* `?value`: the geometry description\n* `?property`: the geometry format\n* `?datatype`: the encoding OR external referenced file\n\n** NOTE!** The query from this tab works without reasoning as long as the named graph in the query matches the one where FOG is stored. The query assumes FOG to be in the named graph `http://ontologies.org/fog/`\n"
        },
        {
            "title": "1b: SELECT specific geometry of any element (with reasoning)",
            "query": "PREFIX omg: <https://w3id.org/omg#>\nPREFIX owl: <http://www.w3.org/2002/07/owl#>\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nPREFIX fog: <https://w3id.org/fog#>\n\nSELECT ?value ?property ?datatype WHERE {\n\t?geometry ?omgProperty ?value ;\n\t\ta omg:Geometry .\n\t?geometry ?property ?value .\n\tBIND(DATATYPE(?value) AS ?datatype)\n\tFILTER (?omgProperty IN (omg:hasSimpleGeometryDescription , omg:hasComplexGeometryDescription))\n\t# only return asserted properties\n\tFILTER NOT EXISTS { \n\t\t?geometry ?otherProperty ?value .\n    \t?otherProperty rdfs:subPropertyOf ?property .\n    \tFILTER (?otherProperty != ?property) # each property is its own subproperty\n\t}\n\tFILTER (?property IN (fog:asGltf_v2.0-glb , fog:asPly_v1.0-ascii))\n}",
            "triples": "",
            "description": "This alternative first query uses **reasoning** and SELECTS **specific geometry** (in this example: `fog:asGltf_v2.0-glb` and `fog:asPly_v1.0-ascii`) it can find in the graph connected to any building element and returns the asserted geometry format (the FOG relation), the datatype for the encoding OR external referenced file (`xsd:string` / `xsd:base64Binary`/ `xsd:hexBinary` OR `xsd:anyURI`) and the actual geometry description (a unicode string in the case of a RDF literal (\"simple\") or the first node of a RDF-based (\"complex\") geometry).\n\nThe returned variables are:\n* `?value`: the geometry description\n* `?property`: the geometry format\n* `?datatype`: the encoding OR external referenced file\n\n** NOTE!** Some of these tabs demand the use of reasoning in every tab (incl. this one). Add the [FOG ontology](https://raw.githubusercontent.com/mathib/fog-ontology/master/fogOnto.ttl) to a named graph in your [running Stardog database](localhost:5820) and do not forget to turn reasoning on in the query component of the SPARQL-visualizer (lower right hand corner). If the query returns no results, press the \"Reset\" button in the query component and reactivate \"Reasoning\".\n"
        },
        {
            "title": "2: SELECT all geometry (without reasoning)",
            "query": "PREFIX omg: <https://w3id.org/omg#>\nPREFIX owl: <http://www.w3.org/2002/07/owl#>\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\n\nSELECT ?value ?property ?datatype WHERE {\n\t?geometry ?property ?value ;\n    \ta omg:Geometry .\n  \tGRAPH <http://ontologies.org/fog/>{\n    \t?property rdfs:subPropertyOf* ?omgProp .\n    \tFILTER (?omgProp IN (omg:hasSimpleGeometryDescription , omg:hasComplexGeometryDescription)) .\n  \t}\n  \tBIND(DATATYPE(?value) AS ?datatype)\n}",
            "triples": "",
            "description": "This second query SELECTS **all geometry** it can find in the graph connected to any building element and returns the asserted geometry format (the FOG relation), the datatype for the encoding (`xsd:string` / `xsd:base64Binary`/ `xsd:hexBinary` OR `xsd:anyURI`) and the actual geometry description (a unicode string in the case of a RDF literal (\"simple\") or the first node of a RDF-based (\"complex\") geometry).\n\nThe returned variables are:\n* `?value`: the geometry description\n* `?property`: the geometry format\n* `?datatype`: the encoding OR external referenced file\n\n** NOTE!** The query from this tab works without reasoning as long as the named graph in the query matches the one where FOG is stored. The query assumes FOG to be in the named graph `http://ontologies.org/fog/`\n"
        },
        {
            "title": "3: SELECT all geometry incl. associated content (without reasoning)",
            "query": "PREFIX omg: <https://w3id.org/omg#>\nPREFIX owl: <http://www.w3.org/2002/07/owl#>\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nPREFIX fog: <https://w3id.org/fog#>\n\nSELECT ?value ?property ?datatype (GROUP_CONCAT(?refName;separator=\"||\") AS ?refNames) (GROUP_CONCAT(?refContent;separator=\"||\") AS ?refContents) WHERE {\n\t?geometry ?property ?value ;\n    \ta omg:Geometry .\n  \tGRAPH <http://ontologies.org/fog/>{\n    \t?property rdfs:subPropertyOf* ?omgProp .\n    \tFILTER (?omgProp IN (omg:hasSimpleGeometryDescription , omg:hasComplexGeometryDescription)) .\n  \t}\n  \tBIND(DATATYPE(?value) AS ?datatype)\n  \t# if available, return the associated content and its name\n  \tOPTIONAL {\n    \t?geometry fog:hasReferencedContent ?ref .\n      \t?ref rdfs:label ?refName ;\n      \t\t?refProperty ?refContent .\n      \tGRAPH <http://ontologies.org/fog/>{\n    \t\t?refProperty rdfs:subPropertyOf* omg:hasSimpleGeometryDescription .\n       \t}\n   \t}\n} GROUP BY ?value ?property ?datatype",
            "triples": "",
            "description": "This third query SELECTS **all geometry** it can find in the graph connected to any building element and returns the asserted geometry format (the FOG relation), the datatype for the encoding (`xsd:string` / `xsd:base64Binary`/ `xsd:hexBinary` OR `xsd:anyURI`) and the actual geometry description (a unicode string in the case of a RDF literal (\"simple\") or the first node of a RDF-based (\"complex\") geometry). Compared to the second query, it also provides the content and name of the associated files (grouped per main geometry description, each associated file separated by \"||\"), if they exist.\n\nThe returned variables are:\n* `?value`: the geometry description\n* `?property`: the geometry format\n* `?datatype`: the encoding OR external referenced file\n* `?refNames`: the original file names of the associated files (separated by '||')\n* `?refContents`: the contents of the associated files (separated by '||')\n\n** NOTE!** The query from this tab works without reasoning as long as the named graph in the query matches the one where FOG is stored. The default named graph is `http://ontologies.org/fog/`\n"
        },
		{
		  "title": "4: SELECT all geometry of one object (without reasoning)",
		  "query": "PREFIX omg: <https://w3id.org/omg#>\nPREFIX owl: <http://www.w3.org/2002/07/owl#>\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nPREFIX bot: <https://w3id.org/bot#>\n\nSELECT ?value ?property ?datatype WHERE {\n\tBIND(<https://example.org/data#column2> AS ?column2)\n\t{\n      \t# geometry directly connected to column2\n    \t?column2 omg:hasGeometry ?geometry .\n \t} UNION {\n    \t# geometry of subparts of column2\n      \t?column2 bot:hasSubElement ?subPart .\n       \t?subPart omg:hasGeometry ?geometry .\n   \t}\n\t?geometry ?property ?value ;\n  \t\ta omg:Geometry .\n\tBIND(DATATYPE(?value) AS ?datatype)\n  \t# only return asserted properties\n   \tGRAPH <http://ontologies.org/fog/>{\n   \t\t?property rdfs:subPropertyOf* ?omgProperty .\n      \tFILTER (?omgProperty IN (omg:hasSimpleGeometryDescription , omg:hasComplexGeometryDescription))\n  \t}\n}",
		  "triples": "",
		  "description": "This fourth query SELECTS all geometry of a specific building element (`ex:column2`) and it subparts. It returns the **asserted** geometry format (the FOG relation), the datatype for the encoding or external referenced file (`xsd:string` / `xsd:base64Binary`/ `xsd:hexBinary` OR `xsd:anyURI`) and the actual geometry description (a unicode string in the case of a RDF literal (\"simple\") or the first node of a RDF-based (\"complex\") geometry).\n\n** NOTE!** The query from this tab works without reasoning as long as the named graph in the query matches the one where FOG is stored. The query assumes FOG to be in the named graph `http://ontologies.org/fog/`"
		},
		{
		  "title": "5: SELECT specific geometry of one object (without reasoning)",
		  "query": "PREFIX fog: <https://w3id.org/fog#>\nPREFIX omg: <https://w3id.org/omg#>\nPREFIX bot: <https://w3id.org/bot#>\n\nSELECT ?value ?property ?datatype WHERE {\n  \tBIND(<https://example.org/data#column1> AS ?column1)\n\t{\n      \t# geometry directly connected to column1\n    \t?column1 omg:hasGeometry ?geometry .\n \t} UNION {\n    \t# geometry of subparts of column1\n      \t?column1 bot:hasSubElement ?subPart .\n       \t?subPart omg:hasGeometry ?geometry .\n   \t}\n\t?geometry ?property ?value .\n\tFILTER (?property IN (fog:asObj_v3.0-obj , fog:asPly_v1.0-ascii))\n   \tBIND(DATATYPE(?value) AS ?datatype)\n}",
		  "triples": "",
		  "description": "This fifth query SELECTS all geometry of a specific building element (`ex:column1`) and it subparts, but only of one or more specified geometry formats (in this example: `fog:asObj_v3.0-obj` and `fog:asPly_v1.0-ascii`). It returns the geometry format (the FOG relation), the datatype for the encoding  OR the external referenced file (`xsd:string` / `xsd:base64Binary`/ `xsd:hexBinary` OR `xsd:anyURI`) and the actual geometry description (a unicode string in the case of a RDF literal (\"simple\") or the first node of a RDF-based (\"complex\")).\n\nThe returned variables are:\n* `?value`: the geometry description\n* `?property`: the geometry format\n* `?datatype`: the encoding OR external referenced file\n\nThis tab does **not** need reasoning.\n"
		}
    ]
}